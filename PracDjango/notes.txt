DJANGO:
https://www.djangoproject.com/
more quick, less code
ridiculously fast: rapid dev
reassuringly secure: csrf protection by default
exceedingly scalable: scalable on bare minimum
EG - paytm

INSTALLATION
dev takes place inside virtual env (separate box, don't affected by our system installations)

CREATING VIRTUAL ENV USING PIP
********** py -m venv <foldername>
********** py -m venv .venv
because virtual env files are generally kept hidden like .gitignore

BUT HERE, WE ARE GOING TO USE uv
********** pip install uv

WHY uv ??
extremely fast package manager written in rust

CREATING VIRTUAL ENV USING UV
********** uv venv

ACTIVATE VIRTUAL ENV
run activate script
********** .venv\Scripts\activate

DEACTIVATE VIRTUAL ENV
********** deactivate

TO INSTALL ANYTHING FURTHER
********** uv pip install <...>

INSTALL DJANGO
********** uv pip install Django

MAKING DJANGO PROJECT
django-admin : main cmd
startproject : first time, it is used
later, multiple small apps are created
startapp

********** django-admin startproject <proj-name>

RUNNING PROJECT
********** cd <proj-name>
********** python manage.py runserver <portNo(opt)>


INDENTATION OR LEVELS
project level, app level, root level (where manage.py is present)

FILES EXPLORATION
manage.py : starting pt
sqlite3: default db in django
project folder(inside wala): create app inside it
__pycache__: optimization as multiple modules are being used
settings.py: whole configuartion (installed apps, middleware[auth also included], etc ....)
urls.py: routing file
views.py: after clicking url, what is shown is written here; defines all views[functionality, business logic]
models.py: databases, models


urls.py[handles routes] --> views.py[return an html file etc...]

----------------------------------------------------------------------------------------------------------------------------------

DJANGO FLOW STRUCTURE

COMPLEX ARCHITECTURE
web framework under the hood uses a tech stack to know about req, res, n/w, browser, etc..
python internally uses event triggers to know about req res

user[needs req res model; eg-login, view tweet, etc..] --> 
user sent a req using browser
req goes to a website(which is running on any server)
req goes to django
django tries to find from where req comes and what it wants to access; eg- /login, /register
for that, django internally has url resolver
url resolver accesses urls.py which may redirect to other urls.py[modular code str]
urls.py sends views.py[main controller]
views.py may direct send a response or via models, db or a response may be sent by via templates
response is sent to django
django sends it to frontend

user --> request --> django --> url resolver --> urls.py --> urls.py, urls.py ... --> views.py --> response / model.py --> db / templates --> django --> response --> user

EASY ARCHITECTURE (in short)
user --> req --> urls.py --> views.py --> res --> user

PATH IN URLS.PY
path(route, view, name of url pattern)

STATIC: for css, js
TEMPLATES: for html

********** in settings.py
'DIRS': ['templates'], # specifying ki django k templates kaha milenge


TEMPLATING ENGINE
html file will work as template engine
template engine: you can inject your code programatically anywhere
********** href="{% static 'style.css'%}
static: loading any static asset
'style.css' : asset
ERROR: Did you forget to register or load this tag?
********** {% load static %} : loading static asset

Templating Engine ðŸ‘‰ Tool jo data + template (HTML) ko combine karke dynamic web pages banata hai.
Django me default templating engine hai Django Template Language (DTL).
Ye kaam karta hai backend se aaye data ko frontend (HTML page) me inject karne ka.

Templating Language ðŸ‘‰ Special syntax (e.g., {{ }}, {% %}) jisse template me variables, loops, conditions likhe jaate hain.

----------------------------------------------------------------------------------------------------------------------------------

JINJA2 or DTL

jinja version 2 is used in django by default
mostly companies use default templating engine, they use jinja
coz in jinja, no further extensions, normal html files, directly inject variables or loops in html

Jinja actually templating engine hai, aur uske andar jo syntax use hota hai (e.g., {{ variable }}, {% for ... %}), usse hum Jinja templating language kehte hain.

SYNTAX

variables {{  }}
{% %}
piping like {{ myDate|date:"Y-m-d" }}
comments {# #}


MAKING APPS IN A PROJECT
project - made 1 time [startproject]
apps - multiple apps inside it [startapp]

w/o manage.py => can't run server and can't create apps 

your main project don't know about these apps
so, first step is to aware about apps to the project
settings.py

********** INSTALLED_APPS = [ cooked in files....., 'app1' ]

TEMPLATES FOR APP
we can make different templates for different apps (no extra setting for this is required)(inside it creating appname folder)
or
we can write their code in different folders within the templates of project

FIXING EMMET SUGGESTIONS OF HTML
installing django extensions => emmet suggestions of html disappear
Ctrl+, > Settings > Emmet > Emmet: Include Language > Add Item > key -> django-html, value -> html > OK

VIEWS DONE IN APP
URLS.PY absent in app
create it
copy project's urls.py, paste it into newly created app's urls.py

URLS.PY(project) ---> URLS.PY, URLS.PY, URLS.PY, ....... (apps)

PASSING CONTROL from project to app
from django.urls import include
urlpatterns = [
    path('appname/', include('app1.urls'))
]

POWER OF JINJA
{% load static %}
block named
{% block <...> %}{% endblock <...> %}
block unnamed
{% block <...>  %}{% endblock  %}

default value can be passed in these blocks
block will be replaced

CREATING A TEMPLATING
i.e. creating a base structure that would be used anywhere

the file which is extended, it is searched by djnago
if it is not in app's templates, it goes to project's templates to search for it because we wrote 'templates' in settings.py

name in urls.py is important